using Content.Client.UserInterface.Controls;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Shared._PANEL;
using System.Linq;
using Robust.Shared.Prototypes;
using Robust.Client.Player;
using Content.Shared.Hands.Components;
using Content.Shared._PANEL.Components;
using Content.Shared.Humanoid;
using Robust.Shared.Timing;
using Content.Client.Chat.Managers;
using Robust.Shared.Random;
using Content.Shared.IdentityManagement;
using Robust.Shared.Containers;
using Content.Shared.Tag;
using Content.Shared.Clothing.Components;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Content.Client._PANEL
{
    [GenerateTypedNameReferences]
    public sealed partial class InteractionWindow : FancyWindow
    {
        private enum Mode
        {
            Interaction,
            Description,
            Favorite
        }
        private Mode _currentMode = Mode.Interaction;
        [Dependency] private readonly IEntityManager _entManager = default!;
        [Dependency] private readonly IUserInterfaceManager _uiManager = default!;
        [Dependency] private readonly IPrototypeManager _proto = default!;
        [Dependency] private readonly IChatManager _chat = default!;
        [Dependency] private readonly IPlayerManager _player = default!;
        [Dependency] private readonly IGameTiming _gameTiming = default!;
        [Dependency] private readonly IRobustRandom _random = default!;
        private readonly InteractionSystem _interactionSystem;

        private InteractionInfo? _selectedInteraction;

        private List<InteractionInfo> _interactionList = new();

        private List<InteractionInfo> _sortedInteractionList = new();

        private List<InteractionInfo> _sortedInteractionListByFavorite = new();

        public IReadOnlyList<InteractionInfo> InteractionInfo => _interactionList;

        public Comparison<InteractionInfo>? Comparison;
        public Func<InteractionInfo, string, string>? OverrideText;
    
        public TimeSpan Cooldown = TimeSpan.Zero;

        public ProgressBar LoveBar;
        public float AccumulatedTime;

        private List<(InteractionInfo, BaseButton, TimeSpan, string)> _disabledItems = new();

        public InteractionWindow()
        {
            // Загрузка UI из XAML
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);
            _interactionSystem = _entManager.System<InteractionSystem>();
            OnOpen += () =>
            {
                StopFiltering();
                _interactionSystem.InteractionListChanged += PopulateList;
            };
            LoveBar = ProgressBar;
            ButtonGroup Group = new();
            InteractionButton.Group = Group;
            DescriptionButton.Group = Group;
            FavoriteButton.Group = Group;
            InteractionButton.Pressed = true;
            InteractionListContainer.ItemPressed += InteractionListItemPressed;
            InteractionButton.OnPressed += Interaction; // переводит режим на основной
            DescriptionButton.OnPressed += Description; // переводит режим на описания
            FavoriteButton.OnPressed += Favorite; // переводит режим на фаворит
            InteractionListContainer.GenerateItem += GenerateButton; // создает кнопки
            SearchBar.OnTextChanged += _ => FilterList(); // вызов фильтрации при попытке найти по серч бару
            InteractionListContainer.SetOnlyStyleClass("darkListContainer"); // заделка на будущих редиз
            SetDescriptions();
        }

        public void Interaction(BaseButton.ButtonEventArgs obj)
        {
            InteractionSelector.Visible = true;
            DescriptionContainer.Visible = false;
            PopulateList();
            _currentMode = Mode.Interaction;
        }

        public void Description(BaseButton.ButtonEventArgs obj)
        {
            InteractionSelector.Visible = false;
            DescriptionContainer.Visible = true;
            PopulateDiscriptions();
            _currentMode = Mode.Description;
        }

        public void Favorite(BaseButton.ButtonEventArgs obj)
        {
            InteractionSelector.Visible = true;
            DescriptionContainer.Visible = false;
            PopulateFavorite();
            _currentMode = Mode.Favorite;
        }

        private void PopulateDiscriptions() // на будущее, когда перейду на билд ласта
        {

        }

        protected override void FrameUpdate(FrameEventArgs args)
        {
            base.FrameUpdate(args);

            foreach ((var info, var item, var time, var text) in _disabledItems)
            {
                var children = item.Children.FirstOrDefault()?.Children?.FirstOrDefault()?.Children?.ElementAtOrDefault(1);

                if (children is Label label)
                    label.Text = $"{text} ({(time - _gameTiming.CurTime).Seconds} сек.)";

                if (_gameTiming.CurTime >= time)
                {
                    item.Disabled = false;
                    _disabledItems.Remove((info, item, time, text));

                    if (children is Label expiredLabel)
                        expiredLabel.Text = text;

                    break;
                }
            }
            AccumulatedTime += args.DeltaSeconds;
            TargetSprite.OverrideDirection = (Direction)((int)AccumulatedTime % 4 * 2);
            UserSprite.OverrideDirection = (Direction)((int)AccumulatedTime % 4 * 2);
        }
        private void InteractionListItemPressed(BaseButton.ButtonEventArgs? args, ListData? data)
        {
            if (args == null || data is not InteractionListData { Info: var selectedInteraction })
                return;

            if (_gameTiming.CurTime >= Cooldown)
            {
                var user = _player.LocalEntity;

                if (!user.HasValue) 
                    return;

                if (!user.Value.IsValid()) 
                    return;
                
                if (!_entManager.TryGetComponent<InteractionComponent>(user, out var interaction))
                    return;

                if (interaction == null)
                    return;

                var item = args.Button;

                var target = _entManager.GetEntity(interaction.Target);

                var text = GetText(selectedInteraction);
    
                item.Disabled = true;

                _disabledItems.Add((selectedInteraction, item, _gameTiming.CurTime + TimeSpan.FromSeconds(2), text));

                if (selectedInteraction.Emotes.Count > 0)
                {
                    if (user == null || target == null)
                        return;

                    string emote = _random.Pick(selectedInteraction.Emotes);
                    emote = emote.Replace("%user", Identity.Name(user.Value, _entManager));
                    emote = emote.Replace("%target", Identity.Name(target.Value, _entManager));
                    _chat.SendMessage(emote, Shared.Chat.ChatSelectChannel.Emotes);
                }
                Cooldown = _gameTiming.CurTime + TimeSpan.FromSeconds(0.5);
            }
        }

        public void StopFiltering()
        {
            SearchBar.Text = string.Empty;
        }


        private bool InhandObjectCheck(InteractionInfo info, EntityUid? uid)
        {
            if (info.InhandObject.Count == 0)
                return true;

            if (!_entManager.TryGetComponent<HandsComponent>(uid, out var hands) ||
                !_entManager.TryGetComponent<MetaDataComponent>(hands.ActiveHandEntity, out var handProto) ||
                handProto.EntityPrototype == null)
                return false;

            return info.InhandObject.Contains(handProto.EntityPrototype.ID);
        }

        private bool SexCheck(InteractionInfo info, EntityUid user, EntityUid? target)
        {
            if (info.UserSex.Count == 0)
                return true;

            if (info.TargetSex.Count == 0)
                return true;

            if (!_entManager.TryGetComponent<HumanoidAppearanceComponent>(user, out var userSex) ||
                !_entManager.TryGetComponent<HumanoidAppearanceComponent>(target, out var targetSex))
                return false;

            return info.UserSex.Contains(userSex.Sex) ||
                info.UserSex.Contains(Sex.Unsexed) &&
                info.TargetSex.Contains(targetSex.Sex) ||
                info.TargetSex.Contains(Sex.Unsexed);
        }
        private void FilterList()
        {
            _sortedInteractionList.Clear();

            if (!_player.LocalEntity.HasValue)
                return;
            
            var user = _player.LocalEntity.Value;

            if (!_entManager.TryGetComponent<InteractionComponent>(user, out var interaction))
                return;

            if (interaction == null)
                return;


            foreach (var info in _interactionList)
            {
                var displayName = $"{info.Name}";

                var target = _entManager.GetEntity(interaction.Target);

                if (!string.IsNullOrEmpty(SearchBar.Text)
                    && !displayName.ToLowerInvariant().Contains(SearchBar.Text.Trim().ToLowerInvariant()))
                    continue;

                if (!_entManager.TryGetComponent<ContainerManagerComponent>(user, out var UserInventory))
                    return;

                if (!_entManager.TryGetComponent<ContainerManagerComponent>(target, out var TargetInventory))
                    return;
        
                HashSet<string> UserCategories = GetRestrictedTags(info.UserTags, UserInventory);
                HashSet<string> TargetCategories = GetRestrictedTags(info.TargetTags, TargetInventory);

                // Проверяем, есть ли нужный предмет в руке
                if (!InhandObjectCheck(info, user))
                    continue;

                // Проверяем пол игрока и таргета
                if (!SexCheck(info, user, target))
                    continue;

                // Проверяем SelfUse: если действие должно быть только на себя, но панель открыта на другом — отбрасываем

                if (target == user && !info.SelfUse)
                    continue;

                if (target != user && info.SelfUse)
                    continue;

                if (!AreTagsAllowed(info.UserTags, info.ProtoUserWhitelist, info.ProtoUserBlacklist, UserCategories))
                    continue;

                if (!AreTagsAllowed(info.TargetTags, info.ProtoTargetWhitelist, info.ProtoTargetBlacklist, TargetCategories))
                    continue;


                // Если все проверки пройдены — добавляем в список
                _sortedInteractionList.Add(info);
            }

            if (Comparison != null)
                _sortedInteractionList.Sort((a, b) => Comparison(a, b));

            InteractionListContainer.PopulateList(_sortedInteractionList.Select(info => new InteractionListData(info)).ToList());

            if (_selectedInteraction != null)
                InteractionListContainer.Select(new InteractionListData(_selectedInteraction));
        }
        
        
        private HashSet<string> GetRestrictedTags(HashSet<string>? tags, ContainerManagerComponent inventory)
        {
            var result = new HashSet<string>();

            if (tags == null)
                return result;

            // foreach (var tag in tags)
            // {
            //     if (!inventory.Containers.TryGetValue(tag, out var container))
            //         continue;

            //     var entity = container.ContainedEntities[0];
            //     result.UnionWith(GetTagBasedRestrictions(tag, entity));
            // }

            return result;
        }


        /// <summary>
        /// Советую не обращать внимание на этот щиткод, если есть варианты по анхардкоду - буду рад услышать о них
        /// </summary>
        private HashSet<string> GetTagBasedRestrictions(string slot, EntityUid entity)
        {
            if (slot == "bra")
                return new HashSet<string> { "грудь" };

            if (slot == "pants")
                return new HashSet<string> { "яйца", "член", "вагина", "анал" };

            if (slot == "socks")
                return new HashSet<string> { "ступни" };

            if (slot == "shoes")
                return new HashSet<string> { "носки", "ступни" };

            if (slot == "jumpsuit")
            {
                if (!_entManager.TryGetComponent<TagComponent>(entity, out var tags))
                    return new HashSet<string> { "грудь", "ляжки", "попа", "яйца", "член", "вагина", "анал" };

                foreach (var tag in tags.Tags)
                {
                    if (tag == "NudeBottom")
                        return new HashSet<string> { "грудь" };

                    if (tag == "NudeTop")
                        return new HashSet<string> { "ляжки", "попа", "яйца", "член", "вагина", "анал" };

                    if (tag == "CommandSuit")
                        return new HashSet<string> { "грудь", "ляжки", "попа", "вагина", "анал" };
                }

                return new HashSet<string> { "грудь", "ляжки", "попа", "яйца", "член", "вагина", "анал" };
            }

            if (slot == "outerClothing")
            {
                if (!_entManager.TryGetComponent<TagComponent>(entity, out var tags))
                    return new HashSet<string> { "грудь", "ляжки", "попа", "яйца", "член", "вагина", "анал" };

                foreach (var tag in tags.Tags)
                {
                    if (tag == "NudeBottom")
                        return new HashSet<string> { "грудь" };

                    if (tag == "NudeFull")
                        return new HashSet<string>();

                    if (tag == "FullCovered")
                        return new HashSet<string> { "щёки", "губы", "шея", "уши", "волосы", "рот", "грудь", "ступни", "ляжки", "попа", "яйца", "член", "вагина", "анал", "лицо", "хвост", "ладони", "гладкие перчатки" };

                    if (tag == "FullBodyOuter")
                        return new HashSet<string> { "грудь", "ступни", "ляжки", "попа", "яйца", "член", "вагина", "анал", "шея", "ладони", "гладкие перчатки" };
                }

                return new HashSet<string> { "грудь", "ляжки", "попа", "яйца", "член", "вагина", "анал" };
            }

            if (slot == "head")
            {
                if (!_entManager.TryGetComponent<TagComponent>(entity, out var tags))
                    return new HashSet<string> { "волосы" };

                foreach (var tag in tags.Tags)
                {
                    if (tag == "TopCovered")
                        return new HashSet<string> { "уши", "волосы" };

                    if (tag == "FullCovered")
                        return new HashSet<string> { "уши", "волосы", "рот", "лицо", "губы", "щёки" };
                }

                return new HashSet<string> { "волосы" };
            }

            if (slot == "gloves")
            {
                if (!_entManager.TryGetComponent<TagComponent>(entity, out var tags))
                    return new HashSet<string> { "ладони", "гладкие перчатки" };

                foreach (var tag in tags.Tags)
                {
                    if (tag == "SmoothGloves")
                        return new HashSet<string> { "ладони" };

                    if (tag == "Ring")
                        return new HashSet<string>();
                }

                return new HashSet<string> { "ладони", "гладкие перчатки" };
            }

            if (slot == "neck")
            {
                if (!_entManager.TryGetComponent<TagComponent>(entity, out var tags))
                    return new HashSet<string> { "шея" };

                foreach (var tag in tags.Tags)
                {
                    if (tag == "OpenNeck")
                        return new HashSet<string>();
                }

                return new HashSet<string> { "шея" };
            }

            if (slot == "mask")
            {
                if (_entManager.TryGetComponent<MaskComponent>(entity, out var mask) && mask.IsToggled)
                    return new HashSet<string>();

                if (_entManager.TryGetComponent<TagComponent>(entity, out var tags))
                {
                    foreach (var tag in tags.Tags)
                    {
                        if (tag == "FaceCovered")
                            return new HashSet<string> { "рот", "щёки", "лицо" };
                    }
                }

                return new HashSet<string> { "рот" };
            }

            return new HashSet<string>();
        }

        private static bool AreTagsAllowed(HashSet<string>? tags, HashSet<string> whiteListTags, HashSet<string> blackListTags,  HashSet<string> categories)
        {
            bool state = true;
            if (tags != null)
            {
                if (blackListTags.Count > 0)
                {
                    foreach (var tag in blackListTags)
                    {
                        if (categories.Contains(tag))
                        {
                            state = false; break;
                        }
                    }
                }

                if (whiteListTags.Count > 0)
                {
                    if (!whiteListTags.Any(tag => tags.Contains(tag)))
                    {
                        state = false;
                    }
                }

            }
            return state;
        }


        public void PopulateList(IReadOnlyList<InteractionInfo>? interactions = null)
        {
            interactions ??= _interactionSystem.InteractionList;

            _interactionList = interactions.ToList();

            FilterList();
        }

        public void PopulateFavorite(IReadOnlyList<InteractionInfo>? interactions = null)
        {
            _sortedInteractionListByFavorite.Clear();

            foreach (var info in _interactionList)
            {
                if (!info.IsPinned)
                    _sortedInteractionList.Remove(info);
            }

            InteractionListContainer.PopulateList(_sortedInteractionList.Select(info => new InteractionListData(info)).ToList());
        }

        public string GetText(InteractionInfo info)
        {
            var text = $"{info.Name}";
            if (OverrideText != null)
                text = OverrideText.Invoke(info, text);
            return text;
        }

        private void GenerateButton(ListData data, ListContainerButton button)
        {
            if (data is not InteractionListData { Info: var info })
                return;
            var entry = new InteractionListEntry();

            entry.Setup(info, OverrideText);

            if (_currentMode == Mode.Favorite)
            {
                entry.OnPinStatusChanged += _ =>
                {
                    PopulateFavorite();
                };          
            }   

            button.AddChild(entry);
            button.AddStyleClass(ListContainer.StyleClassListContainerButton);
        }

        private void AddClothingLabel(Control description, EntityUid? uid, string text)
        {
            if (HasClothing(uid))
                description.AddChild(new Label { Text = Loc.GetString(text) });
        }

        // Adds sex-specific labels based on conditions
        private void AddSexLabels(Control description, Sex sex, string[] text)
        {
            if (sex == Sex.Female || sex == Sex.Male)
            {
                foreach (var key in text)
                {
                    description.AddChild(new Label { Text = Loc.GetString(key) });
                }
            }
        }
    
        private void SetDescriptions()
        { 
            if (!_player.LocalEntity.HasValue)
                return;
            
            var user = _player.LocalEntity.Value; 

            if (!_entManager.TryGetComponent<InteractionComponent>(user, out var interaction))
                return;

            var target = _entManager.GetEntity(interaction.Target);

            if (!_entManager.TryGetComponent<HumanoidAppearanceComponent>(user, out var userSex) ||
                !_entManager.TryGetComponent<HumanoidAppearanceComponent>(target, out var targetSex))
                return;

            // Описание User (всегда добавляется, независимо от одежды)
            AddClothingLabel(UserDescription, user, "user-has-clothing");

            if (userSex.Sex == Sex.Female)
            {
                AddSexLabels(UserDescription, Sex.Female, new[] { "user-women-1", "user-women-2", "user-women-3" });
            }
            else if (userSex.Sex == Sex.Male)
            {
                AddSexLabels(UserDescription, Sex.Male, new[] { "user-male-1", "user-male-2" });
            }

            // Описание Target (проверяется одежда)
            AddClothingLabel(TargetDescription, target, "target-has-clothing");

            if (targetSex.Sex == Sex.Female && !HasClothing(target))
            {
                AddSexLabels(TargetDescription, Sex.Female, new[] { "target-women-1", "target-women-2", "target-women-3" });
            }
            else if (targetSex.Sex == Sex.Male && !HasClothing(target))
            {
                AddSexLabels(TargetDescription, Sex.Male, new[] { "target-male-1", "target-male-2" });
            }

            TargetSprite.SetEntity(target);
            UserSprite.SetEntity(user);
        }
    
        private bool HasClothing(EntityUid? uid)
        {
        if (!_entManager.TryGetComponent<ContainerManagerComponent>(uid, out var containerManager) || containerManager == null)
            return false;

        if (containerManager.Containers.TryGetValue("jumpsuit", out var jumpsuit) && jumpsuit.ContainedEntities.Count != 0 )
            return true;

        if (containerManager.Containers.TryGetValue("outerClothing", out var outerClothing) && outerClothing.ContainedEntities.Count != 0)
            return true;

        return false;
        }
    }

    public record InteractionListData(InteractionInfo Info) : ListData;
}
